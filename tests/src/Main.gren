module Main exposing (main)

import Db exposing (Error(..))
import Db.Decode exposing (Decoder)
import Db.Encode
import Expect
import HttpClient
import Init
import Node
import Task exposing (Task)
import Test.Runner.Effectful exposing 
    ( Test
    , await
    , awaitError
    , concat
    , describe
    , run
    , test
    )
import Time


-- RUNNER


config =
    { credentials = Nothing
    , url = "http://localhost:12321/test"
    }


main : Node.SimpleProgram a
main =
    Node.defineSimpleProgram <| \env ->
        Init.await HttpClient.initialize <| \httpPerm ->
            let
                connection =
                    connect httpPerm
            in
            run env <|
                concat
                    [ executeTests connection
                    , transactionTests connection
                    , getOneTests connection
                    , getMaybeOneTests connection
                    , getAllTests connection
                    , encodeDecodeTests connection
                    ]


-- EXECUTE TESTS


executeTests : Db.Connection -> Test
executeTests connection =
    let
        execute =
            Db.execute connection
                { statement = "insert into users (id, name) values (1, \"one\")"
                , parameters = []
                }
    in
    await (reset connection) "Reset DB for execute tests" <| \_ ->
    await execute "Execute statement" <| \executeResult ->
        test "returns number of affected rows" <| \_ ->
            Expect.equal 1 executeResult


-- TRANSACTION TESTS


transactionTests : Db.Connection -> Test
transactionTests connection =
    let
        insertSuccess = 
            Db.transaction connection
                [ { statement = "insert into users (id, name) values (1, \"one\")"
                  , parameters = []
                  }
                , { statement = "insert into users (id, name) values (2, \"two\")"
                  , parameters = []
                  }
                ]

        insertFailure =
            Db.transaction connection
                [ { statement = "insert into users (id, name) values (1, \"yo\")"
                  , parameters = []
                  }
                , { statement = "insert into users (nope, wrong) values (1, 2)"
                  , parameters = []
                  }
                ]

        get =
            Db.getAll connection
                { query = "select * from users order by id asc"
                , parameters = []
                , decoder = userDecoder
                }

        transactionSuccess =
            reset connection
                |> Task.andThen (\_ -> insertSuccess)
                |> Task.andThen (\_ -> get)

        transactionFailure =
            reset connection
                |> Task.andThen (\_ -> insertFailure)
                |> Task.map (\_ -> [])
                |> Task.onError (\_ -> get)
    in
    describe "Transactions"
        [ await transactionSuccess "successful transaction" <| \result ->
            test "commits all statements in the transaction" <| \_ ->
                [ { id = 1, name = "one" }, { id = 2, name = "two" } ]
                    |> Expect.equal result

        , await transactionFailure "failed transaction" <| \result ->
            test "does not commit any statements in the transaction" <| \_ ->
                Expect.equal [] result
        ]


-- QUERY TESTS


getOneTests : Db.Connection -> Test
getOneTests connection =
    await (initUsers connection [user1]) "Insert test user for getOne tests" <| \_ ->
        describe "Db.getOne"
            [ await (getOne connection user1.id) "Get test user" <| \result ->
                test "returns 1 user" <| \_ ->
                    Expect.equal user1 result

            , awaitError (getOne connection 99) "Get non-existant user" <| \error ->
                test "returns NoResultError" <| \_ ->
                    Expect.equal NoResultError error

            , await (initUsers connection [user1, user1]) "Insert duplicate users" <| \_ ->
                concat
                    [ awaitError (getOne connection 1) "Get one duplicated user" <| \error ->
                        test "returns MultipleResultsError" <| \_ ->
                            Expect.equal (MultipleResultsError 2) error

                    , await (getOneCustom connection 1 "select * from users limit 1") "Get one with limit" <| \result ->
                        test "returns one instance of user" <| \_ ->
                            Expect.equal user1 result
                    ]
            ]


getMaybeOneTests : Db.Connection -> Test
getMaybeOneTests connection =
    await (initUsers connection [user1]) "Insert test user for getMaybeOne tests" <| \_ ->
        describe "Db.getOne"
            [ await (getMaybeOne connection user1.id) "Maybe get test user" <| \result ->
                test "returns Just user" <| \_ ->
                    Expect.equal (Just user1) result

            , await (getMaybeOne connection 99) "Maybe get non-existant user" <| \result ->
                test "returns Nothing" <| \_ ->
                    Expect.equal Nothing result

            , await (initUsers connection [user1, user1]) "Insert duplicate users" <| \_ ->
                concat
                    [ await (getMaybeOne connection 1) "Maybe get one duplicated user" <| \result ->
                        test "returns Nothing" <| \_ ->
                            Expect.equal Nothing result

                    , await (getMaybeOneCustom connection 1 "select * from users limit 1") "Maybe get one with limit" <| \result ->
                        test "returns one instance of user" <| \_ ->
                            Expect.equal (Just user1) result
                    ]
            ]


getAllTests : Db.Connection -> Test
getAllTests connection =
    describe "Db.getAll tests"
        [ await (reset connection) "with no users" <| \_ ->
          await (getAll connection) "getAll" <| \result ->
              test "returns empty array" <| \_ ->
                  Expect.equal [] result

        , await (initUsers connection [user1]) "with one user" <| \_ ->
          await (getAll connection) "getAll" <| \result ->
              test "returns array with just the user" <| \_ ->
                  Expect.equal [user1] result

        , await (initUsers connection [user1, user2]) "with two users" <| \_ ->
          await (getAll connection) "getAll" <| \result ->
              test "returns array with both users" <| \_ ->
                  Expect.equal [user1, user2] result
        ]


-- USERS


type alias User =
    { id : Int
    , name : String
    }


userDecoder : Decoder User
userDecoder =
    Db.Decode.map2
        (\id name -> { id = id, name = name })
        (Db.Decode.field "id" Db.Decode.int)
        (Db.Decode.field "name" Db.Decode.string)


user1 : User
user1 =
    { id = 1, name = "one" }


user2 : User
user2 =
    { id = 2, name = "two" }


-- ENCODE / DECODE TESTS


type alias AllTypes =
    { nullableInt : Maybe Int
    , float : Float
    , string : String
    , bool : Bool
    , posix : Time.Posix
    }


allTypesDecoder : Decoder AllTypes
allTypesDecoder =
    Db.Decode.map5
        (\nullableInt float string bool posix -> 
            { nullableInt = nullableInt
            , float = float
            , string = string
            , bool = bool
            , posix = posix
            }
        )
        (Db.Decode.field "nullableInt" (Db.Decode.nullable Db.Decode.int))
        (Db.Decode.field "float" Db.Decode.float)
        (Db.Decode.field "string" Db.Decode.string)
        (Db.Decode.field "bool" Db.Decode.bool)
        (Db.Decode.field "posix" Db.Decode.posix)


encodeDecodeTests : Db.Connection -> Test
encodeDecodeTests connection =
    let
        insert : AllTypes -> Task Db.Error Int
        insert record =
            let
                nullableInt =
                    when record.nullableInt is
                        Just i ->
                            Db.Encode.int i
                        Nothing ->
                            Db.Encode.null
            in
            Db.execute connection
                { statement =
                   """
                   insert into allTypes (nullableInt, float, string, bool, posix)
                   values (:nullableInt, :float, :string, :bool, :posix)
                   """
                , parameters =
                    [ { key = "nullableInt", value = nullableInt }
                    , { key = "float", value = Db.Encode.float record.float }
                    , { key = "string", value = Db.Encode.string record.string }
                    , { key = "bool", value = Db.Encode.bool record.bool }
                    , { key = "posix", value = Db.Encode.posix record.posix }
                    ]
                }

        insertWithStringBools : Task Db.Error Int
        insertWithStringBools =
            Db.execute connection
                { statement =
                   """
                   insert into allTypes (nullableInt, float, string, bool, posix) values
                       (1, 1.0, "", "TRUE", 1),
                       (2, 2.0, "", "FALSE", 2)
                   """
                , parameters = []
                }

        get : Task Db.Error AllTypes
        get =
            Db.getOne connection
                { parameters = []
                , decoder = allTypesDecoder
                , query = "select * from allTypes order by nullableInt asc"
                }

        getAll_ : Task Db.Error (Array AllTypes)
        getAll_ =
            Db.getAll connection
                { parameters = []
                , decoder = allTypesDecoder
                , query = "select * from allTypes"
                }

        task : AllTypes -> Task Db.Error AllTypes 
        task record =
            reset connection
                |> Task.andThen (\_ -> insert record)
                |> Task.andThen (\_ -> get)

        allTypes =
            { nullableInt = Just 1
            , float = 1.23
            , string = "abc"
            , bool = True
            , posix = Time.millisToPosix 123
            }

        allTypesWithNegatives =
            { allTypes 
                | nullableInt = Nothing 
                , bool = False
            }
    in
    concat
        [ await (task allTypes) "insert and get" <| \result ->
            test "encodes and decodes" <| \_ ->
                Expect.equal allTypes result

        , await (task allTypesWithNegatives) "insert and get with falsey values" <| \result ->
            test "encodes and decodes with falsey values" <| \_ ->
                Expect.equal allTypesWithNegatives result
        
        , await (reset connection) "Reset allTypes table" <| \_ ->
          await insertWithStringBools "Insert TRUE/FALSE rows" <| \_ ->
          await getAll_ "Get TRUE/FALSE rows" <| \result ->
            test "successfully decodes TRUE/FALSE as bools" <| \_ ->
                Expect.equal result
                    [ { nullableInt = Just 1
                      , float = 1.0
                      , string = ""
                      , bool = True
                      , posix = Time.millisToPosix 1
                      }
                    , { nullableInt = Just 2
                      , float = 2.0
                      , string = ""
                      , bool = False
                      , posix = Time.millisToPosix 2
                      }
                    ]
        ]


-- HELPERS


connect : HttpClient.Permission -> Db.Connection
connect permission =
    Db.init permission config


reset : Db.Connection -> Task Db.Error (Array Int)
reset connection =
    Db.transaction connection
        [ { parameters = []
          , statement =
            """
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER,
                name TEXT NOT NULL
            )
            """
          }
        , { parameters = []
          , statement =
            """
            CREATE TABLE IF NOT EXISTS allTypes (
                nullableInt INTEGER,
                float REAL NOT NULL,
                string TEXT NOT NULL,
                bool INTEGER,
                posix INTEGER
            )
            """
          }
        , { parameters = []
          , statement = "DELETE FROM users"
          }
        , { parameters = []
          , statement = "DELETE FROM allTypes"
          }
        ]


insertUsers : Db.Connection -> Array User -> Task Db.Error (Array Int)
insertUsers connection users =
    users
        |> Array.map
            (\{id, name} ->
                { statement = "insert into users (id, name) values (:id, :name)"
                , parameters =
                    [ { key = "id", value = Db.Encode.int id }
                    , { key = "name", value = Db.Encode.string name }
                    ]
                }
            )
        |> Db.transaction connection


initUsers : Db.Connection -> Array User -> Task Db.Error (Array Int)
initUsers connection users =
    reset connection
        |> Task.andThen (\_ -> insertUsers connection users)


getOne : Db.Connection -> Int -> Task Db.Error User
getOne connection id =
    Db.getOne connection
        { query = "select * from users where id = :id"
        , parameters = [{ key = "id", value = Db.Encode.int id }]
        , decoder = userDecoder
        }


getMaybeOne : Db.Connection -> Int -> Task Db.Error (Maybe User)
getMaybeOne connection id =
    Db.getMaybeOne connection
        { query = "select * from users where id = :id"
        , parameters = [{ key = "id", value = Db.Encode.int id }]
        , decoder = userDecoder
        }


getOneCustom : Db.Connection -> Int -> String -> Task Db.Error User
getOneCustom connection id query =
    Db.getOne connection
        { query = query
        , parameters = [{ key = "id", value = Db.Encode.int id }]
        , decoder = userDecoder
        }


getMaybeOneCustom : Db.Connection -> Int -> String -> Task Db.Error (Maybe User)
getMaybeOneCustom connection id query =
    Db.getMaybeOne connection
        { query = query
        , parameters = [{ key = "id", value = Db.Encode.int id }]
        , decoder = userDecoder
        }


getAll : Db.Connection -> Task Db.Error (Array User)
getAll connection =
    Db.getAll connection
        { query = "select * from users order by id"
        , parameters = []
        , decoder = userDecoder
        }

