module Main exposing (main)

import Bytes
import Db exposing (Error(..))
import Db.Decode exposing (Decoder)
import Db.Encode
import Expect
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Init
import Node
import Task exposing (Task)
import Test.Runner.Effectful exposing 
    ( Test
    , await
    , awaitError
    , concat
    , describe
    , run
    , test
    )
import Time


logPath : Path
logPath =
    Path.fromPosixString "db/test.log"


-- RUNNER


main : Node.SimpleProgram a
main =
    Node.defineSimpleProgram <| \env ->
        Init.await HttpClient.initialize <| \httpPerm ->
        Init.await FileSystem.initialize <| \fsPermission ->
            let
                connection =
                    Db.init httpPerm "http://localhost:12321/test"

                connectionWithAuth =
                    Db.init httpPerm "http://localhost:12322/test-with-auth"

                seedLog =
                    FileSystem.writeFile fsPermission
                        (Bytes.fromString "existing log line\n")
                        logPath
            in
            run env <|
                await "Seed log lines" seedLog <| \_ ->
                    concat
                        [ executeTests connection
                        , transactionTests connection
                        , getOneTests connection
                        , getMaybeOneTests connection
                        , getAllTests connection
                        , encodeDecodeTests connection
                        , getNTests connection
                        , errorTests connection
                        , authTests connectionWithAuth
                        , loggingTests fsPermission connection
                        , fancyDecodingTests connection
                        ]


-- EXECUTE TESTS


executeTests : Db.Connection -> Test
executeTests connection =
    let
        execute =
            Db.execute connection
                { statement = "insert into users (id, name) values (1, \"one\")"
                , parameters = []
                }
    in
    await "Reset DB for execute tests" (reset connection) <| \_ ->
    await "Execute statement" execute <| \executeResult ->
        test "returns number of affected rows" <| \_ ->
            Expect.equal 1 executeResult


-- TRANSACTION TESTS


transactionTests : Db.Connection -> Test
transactionTests connection =
    let
        insertSuccess = 
            Db.transaction connection
                [ { statement = "insert into users (id, name) values (1, \"one\")"
                  , parameters = []
                  }
                , { statement = "insert into users (id, name) values (2, \"two\")"
                  , parameters = []
                  }
                ]

        insertFailure =
            Db.transaction connection
                [ { statement = "insert into users (id, name) values (1, \"yo\")"
                  , parameters = []
                  }
                , { statement = "insert into users (nope, wrong) values (1, 2)"
                  , parameters = []
                  }
                ]

        get =
            Db.getAll connection
                { query = "select * from users order by id asc"
                , parameters = []
                , decoder = userDecoder
                }

        transactionSuccess =
            reset connection
                |> Task.andThen (\_ -> insertSuccess)
                |> Task.andThen (\_ -> get)

        transactionFailure =
            reset connection
                |> Task.andThen (\_ -> insertFailure)
                |> Task.map (\_ -> [])
                |> Task.onError (\_ -> get)
    in
    describe "Transactions"
        [ await "successful transaction" transactionSuccess <| \result ->
            test "commits all statements in the transaction" <| \_ ->
                [ { id = 1, name = "one" }, { id = 2, name = "two" } ]
                    |> Expect.equal result

        , await "failed transaction" transactionFailure <| \result ->
            test "does not commit any statements in the transaction" <| \_ ->
                Expect.equal [] result
        ]


-- QUERY TESTS


getOneTests : Db.Connection -> Test
getOneTests connection =
    await "Insert test user for getOne tests" (initUsers connection [user1]) <| \_ ->
        describe "Db.getOne"
            [ await "Get test user" (getOneUser connection user1.id) <| \result ->
                test "returns 1 user" <| \_ ->
                    Expect.equal user1 result

            , awaitError "Get non-existant user" (getOneUser connection 99) <| \error ->
                test "returns NoResultError" <| \_ ->
                    Expect.equal NoResultError error

            , await "Insert duplicate users" (initUsers connection [user1, user1]) <| \_ ->
                concat
                    [ awaitError "Get one duplicated user" (getOneUser connection 1) <| \error ->
                        test "returns MultipleResultsError" <| \_ ->
                            Expect.equal (MultipleResultsError 2) error

                    , await "Get one with limit" 
                        (getOneUserCustom connection 1 "select * from users limit 1")
                        (\result ->
                            test "returns one instance of user" <| \_ ->
                                Expect.equal user1 result
                        )
                    ]
            ]


getMaybeOneTests : Db.Connection -> Test
getMaybeOneTests connection =
    await "Insert test user for getMaybeOne tests" (initUsers connection [user1]) <| \_ ->
        describe "Db.getOne"
            [ await "Maybe get test user" (getMaybeOneUser connection user1.id) <| \result ->
                test "returns Just user" <| \_ ->
                    Expect.equal (Just user1) result

            , await "Maybe get non-existant user" (getMaybeOneUser connection 99) <| \result ->
                test "returns Nothing" <| \_ ->
                    Expect.equal Nothing result

            , await "Insert duplicate users" (initUsers connection [user1, user1]) <| \_ ->
                concat
                    [ await "Maybe get one duplicated user" (getMaybeOneUser connection 1) <| \result ->
                        test "returns Nothing" <| \_ ->
                            Expect.equal Nothing result

                    , await "Maybe get one with limit" 
                        (getMaybeOneUserCustom connection 1 "select * from users limit 1")
                        (\result ->
                            test "returns one instance of user" <| \_ ->
                                Expect.equal (Just user1) result
                        )
                    ]
            ]


getAllTests : Db.Connection -> Test
getAllTests connection =
    describe "Db.getAll tests"
        [ await "with no users" (reset connection) <| \_ ->
          await "getAll" (getAllUsers connection) <| \result ->
              test "returns empty array" <| \_ ->
                  Expect.equal [] result

        , await "with one user" (initUsers connection [user1]) <| \_ ->
          await "getAll" (getAllUsers connection) <| \result ->
              test "returns array with just the user" <| \_ ->
                  Expect.equal [user1] result

        , await "with two users" (initUsers connection [user1, user2]) <| \_ ->
          await "getAll" (getAllUsers connection) <| \result ->
              test "returns array with both users" <| \_ ->
                  Expect.equal [user1, user2] result
        ]


-- ERROR TESTS


errorTests : Db.Connection -> Test
errorTests connection =
    let
        badSql =
            { statement = "select blah, from ohno"
            , parameters = []
            }
    in
    await "Insert duplicate users for error tests" (initUsers connection [user1, user1]) <| \_ ->
        describe "Db.errorToString"
            [ awaitError "with NoResultError" (getOneUser connection 99) <| \error ->
                test "returns no results error string" <| \_ ->
                    error
                        |> Db.errorToString
                        |> Expect.equal "Expected one result, got none"

            , awaitError "with MultipleResultsError" (getOneUser connection 1) <| \error ->
                test "returns multiple result error string" <| \_ ->
                    error
                        |> Db.errorToString
                        |> Expect.equal "Expected one result, got 2"

            , awaitError "with Error" (Db.execute connection badSql) <| \error ->
                test "returns error string from database" <| \_ ->
                    error
                        |> Db.errorToString
                        --|> Debug.log "error"
                        |> (\s -> 
                                String.contains "Internal Server Error" s
                                    |> Expect.equal True
                           )
            ]


-- ENCODE / DECODE TESTS


type alias AllTypes =
    { nullableInt : Maybe Int
    , float : Float
    , string : String
    , bool : Bool
    , posix : Time.Posix
    }


allTypesDecoder : Decoder AllTypes
allTypesDecoder =
    Db.Decode.get5
        (Db.Decode.maybe Db.Decode.int "nullableInt")
        (Db.Decode.float "float")
        (Db.Decode.string "string")
        (Db.Decode.bool "bool")
        (Db.Decode.posix "posix")
        (\maybeInt float string bool posix -> 
            { nullableInt = maybeInt
            , float = float
            , string = string
            , bool = bool
            , posix = posix
            }
        )


encodeDecodeTests : Db.Connection -> Test
encodeDecodeTests connection =
    let
        insert : AllTypes -> Task Db.Error Int
        insert record =
            let
                nullableIntEncoder =
                    when record.nullableInt is
                        Just i ->
                            Db.Encode.int "nullableInt" i
                        Nothing ->
                            Db.Encode.null "nullableInt"
            in
            Db.execute connection
                { statement =
                   """
                   insert into allTypes (nullableInt, float, string, bool, posix)
                   values (:nullableInt, :float, :string, :bool, :posix)
                   """
                , parameters =
                    [ nullableIntEncoder
                    , Db.Encode.float "float" record.float
                    , Db.Encode.string "string" record.string
                    , Db.Encode.bool "bool" record.bool
                    , Db.Encode.posix "posix" record.posix
                    ]
                }

        insertWithStringBools : Task Db.Error Int
        insertWithStringBools =
            Db.execute connection
                { statement =
                   """
                   insert into allTypes (nullableInt, float, string, bool, posix) values
                       (1, 1.0, "", "TRUE", 1),
                       (2, 2.0, "", "FALSE", 2)
                   """
                , parameters = []
                }

        get : Task Db.Error AllTypes
        get =
            Db.getOne connection
                { parameters = []
                , decoder = allTypesDecoder
                , query = "select * from allTypes order by nullableInt asc"
                }

        getAll_ : Task Db.Error (Array AllTypes)
        getAll_ =
            Db.getAll connection
                { parameters = []
                , decoder = allTypesDecoder
                , query = "select * from allTypes"
                }

        task : AllTypes -> Task Db.Error AllTypes 
        task record =
            reset connection
                |> Task.andThen (\_ -> insert record)
                |> Task.andThen (\_ -> get)

        allTypes =
            { nullableInt = Just 1
            , float = 1.23
            , string = "abc"
            , bool = True
            , posix = Time.millisToPosix 123
            }

        allTypesWithNegatives =
            { allTypes 
                | nullableInt = Nothing 
                , bool = False
            }
    in
    concat
        [ await "insert and get" (task allTypes) <| \result ->
            test "encodes and decodes" <| \_ ->
                Expect.equal allTypes result

        , await "insert and get with falsey values" (task allTypesWithNegatives) <| \result ->
            test "encodes and decodes with falsey values" <| \_ ->
                Expect.equal allTypesWithNegatives result
        
        , await "Reset allTypes table" (reset connection) <| \_ ->
          await "Insert TRUE/FALSE rows" insertWithStringBools <| \_ ->
          await "Get TRUE/FALSE rows" getAll_ <| \result ->
            test "successfully decodes TRUE/FALSE as bools" <| \_ ->
                Expect.equal result
                    [ { nullableInt = Just 1
                      , float = 1.0
                      , string = ""
                      , bool = True
                      , posix = Time.millisToPosix 1
                      }
                    , { nullableInt = Just 2
                      , float = 2.0
                      , string = ""
                      , bool = False
                      , posix = Time.millisToPosix 2
                      }
                    ]
        ]


-- GETN TESTS


getNTests : Db.Connection -> Test
getNTests connection =
    let
        get1 =
            Db.getOne connection
                { query = "select 1 as one"
                , parameters = []
                , decoder =
                    Db.Decode.int "one"
                        |> Db.Decode.map
                            (\one -> [ one ])
                }

        get2 =
            Db.getOne connection
                { query = "select 1 as one, 2 as two"
                , parameters = []
                , decoder =
                    Db.Decode.get2
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (\one two -> [ one, two ])
                }

        get3 =
            Db.getOne connection
                { query = "select 1 as one, 2 as two, 3 as three"
                , parameters = []
                , decoder =
                    Db.Decode.get3
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (\one two three -> [ one, two, three ])
                }

        get4 =
            Db.getOne connection
                { query = 
                    """
                    select
                        1 as one,
                        2 as two,
                        3 as three,
                        4 as four
                    """
                , parameters = []
                , decoder =
                    Db.Decode.get4
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (Db.Decode.int "four")
                        (\one two three four -> 
                            [ one
                            , two
                            , three
                            , four
                            ]
                        )
                }

        get5 =
            Db.getOne connection
                { query = 
                    """
                    select
                        1 as one,
                        2 as two,
                        3 as three,
                        4 as four,
                        5 as five
                    """
                , parameters = []
                , decoder =
                    Db.Decode.get5
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (Db.Decode.int "four")
                        (Db.Decode.int "five")
                        (\one two three four five -> 
                            [ one
                            , two
                            , three
                            , four
                            , five
                            ]
                        )
                }

        get6 =
            Db.getOne connection
                { query = 
                    """
                    select
                        1 as one,
                        2 as two,
                        3 as three,
                        4 as four,
                        5 as five,
                        6 as six
                    """
                , parameters = []
                , decoder =
                    Db.Decode.get6
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (Db.Decode.int "four")
                        (Db.Decode.int "five")
                        (Db.Decode.int "six")
                        (\one two three four five six -> 
                            [ one
                            , two
                            , three
                            , four
                            , five
                            , six
                            ]
                        )
                }

        get7 =
            Db.getOne connection
                { query = 
                    """
                    select
                        1 as one,
                        2 as two,
                        3 as three,
                        4 as four,
                        5 as five,
                        6 as six,
                        7 as seven
                    """
                , parameters = []
                , decoder =
                    Db.Decode.get7
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (Db.Decode.int "four")
                        (Db.Decode.int "five")
                        (Db.Decode.int "six")
                        (Db.Decode.int "seven")
                        (\one two three four five six seven -> 
                            [ one
                            , two
                            , three
                            , four
                            , five
                            , six
                            , seven
                            ]
                        )
                }

        get8 =
            Db.getOne connection
                { query = 
                    """
                    select
                        1 as one,
                        2 as two,
                        3 as three,
                        4 as four,
                        5 as five,
                        6 as six,
                        7 as seven,
                        8 as eight
                    """
                , parameters = []
                , decoder =
                    Db.Decode.get8
                        (Db.Decode.int "one")
                        (Db.Decode.int "two")
                        (Db.Decode.int "three")
                        (Db.Decode.int "four")
                        (Db.Decode.int "five")
                        (Db.Decode.int "six")
                        (Db.Decode.int "seven")
                        (Db.Decode.int "eight")
                        (\one two three four five six seven eight -> 
                            [ one
                            , two
                            , three
                            , four
                            , five
                            , six
                            , seven
                            , eight
                            ]
                        )
                }
    in
    describe "getN tests"
        [ await "get one field" get1 <| \result ->
            test "get1" <| \_ ->
                Expect.equal [1] result

        , await "get two fields" get2 <| \result ->
            test "get2" <| \_ ->
                Expect.equal [1, 2] result

        , await "get three fields" get3 <| \result ->
            test "get3" <| \_ ->
                Expect.equal [1, 2, 3] result

        , await "get four fields" get4 <| \result ->
            test "get4" <| \_ ->
                Expect.equal [1, 2, 3, 4] result

        , await "get five fields" get5 <| \result ->
            test "get5" <| \_ ->
                Expect.equal [1, 2, 3, 4, 5] result

        , await "get six fields" get6 <| \result ->
            test "get6" <| \_ ->
                Expect.equal [1, 2, 3, 4, 5, 6] result

        , await "get seven fields" get7 <| \result ->
            test "get7" <| \_ ->
                Expect.equal [1, 2, 3, 4, 5, 6, 7] result

        , await "get eight fields" get8 <| \result ->
            test "get8" <| \_ ->
                Expect.equal [1, 2, 3, 4, 5, 6, 7, 8] result
        ]


-- LOGGING TESTS


loggingTests : FileSystem.Permission -> Db.Connection -> Test
loggingTests fsPermission connection =
    let
        con =
            Db.withLogFile fsPermission logPath connection

        execute =
            Db.execute con
                { statement = 
                    """
                    insert into users (id, name)
                    values (:id, :name)
                    """
                , parameters = 
                    [ Db.Encode.int "id" 12321
                    , Db.Encode.string "name" "HOTDOGS"
                    ]
                }

        query =
            Db.getOne con
                { query = "select 42 as everything"
                , parameters = []
                , decoder = 
                    Db.Decode.int "everything"
                }

        readLogFile =
            FileSystem.readFile fsPermission logPath
                |> Task.map Bytes.toString
                |> Task.map (Maybe.withDefault "BYTES DECODING FAILED")
    in
    await "Execute with logging" execute <| \executeResult ->
    await "Query with logging" query <| \queryResult ->
    await "Read log file" readLogFile <| \logContents ->
        -- let
        --     _ =
        --         Debug.log "log" logContents
        -- in
        describe "Db connection with logging enabled"
            [ test "Executes statements normally" <| \_ ->
                Expect.equal 1 executeResult
            , test "Executes queries normally" <| \_ ->
                Expect.equal 42 queryResult
            , test "Logs requests" <| \_ ->
                [ String.contains "insert into users" logContents
                , String.contains "12321" logContents
                , String.contains "HOTDOGS" logContents
                , String.contains "select 42 as everything" logContents
                ]
                    |> Expect.equalArrays
                        [ True
                        , True
                        , True
                        , True
                        ]
            , test "Does not overwrite existing log lines" <| \_ ->
                String.contains "existing log line" logContents
                    |> Expect.equal True
            ]


-- AUTH TESTS


authTests : Db.Connection -> Test
authTests connection =
    let
        execute =
            Db.execute connection
                { statement = "select 1"
                , parameters = []
                }

        connectionWithAuth =
            connection
                |> Db.withAuth
                    -- see Justfile
                    { user = "myuser"
                    , password = "mypass"
                    }

        executeWithAuth =
            Db.execute connectionWithAuth
                { statement = "select 1"
                , parameters = []
                }
    in
    describe "Auth tests"
        [ awaitError "Execute statement when auth is required" execute <| \result ->
            test "results in authentication error" <| \_ ->
                when result is
                    Error _ ->
                        Expect.pass

                    _ ->
                        Expect.fail <|
                            "Did not fail with expected error variant: " ++
                            Debug.toString result
        
        , await "Execute statement with auth" executeWithAuth <| \result ->
            test "succeeds without authentication error" <| \_ ->
                Expect.equal 0 result
        ]


-- FANCY DECODING


type alias OneTwo =
    { one : String
    , two : String
    }


fancyDecoder : Decoder OneTwo
fancyDecoder =
    Db.Decode.get2
        (Db.Decode.int "one" |> Db.Decode.map String.fromInt |> Db.Decode.andThen (\i -> Db.Decode.succeed ("one: " ++ i)))
        (Db.Decode.int "two")
        (\one two -> { one = one, two = two })
            |> Db.Decode.map
                (\{ one, two } ->
                    { one = one
                    , two = String.fromInt two
                    }
                )
            |> Db.Decode.andThen
                (\{ one, two } ->
                    Db.Decode.succeed
                        { one = one
                        , two = "two: " ++ two
                        }
                )


fancyQuery : Db.Connection -> Task Db.Error OneTwo
fancyQuery connection =
    Db.getOne connection
        { query = "select 1 as one, 2 as two"
        , parameters = []
        , decoder = fancyDecoder
        }


failDecoding : Db.Connection -> Task Db.Error Int
failDecoding connection =
    Db.getOne connection
        { query = "select 1"
        , parameters = []
        , decoder = Db.Decode.fail "Oopsy!"
        }


fancyDecodingTests : Db.Connection -> Test
fancyDecodingTests connection =
    describe "Fancy decoder tests"
        [ await "Run query with fancy decoder" (fancyQuery connection) <| \result ->
            test "decodes fancy result" <| \_ ->
                Expect.equal
                    { one = "one: 1", two = "two: 2" }
                    result
        
        , awaitError "Forcing a decode failure" (failDecoding connection) <| \result ->
            test "results in decoding error" <| \_ ->
                when result is
                    Error s ->
                        String.contains "Oopsy!" s
                            |> Expect.equal True

                    _ ->
                        Expect.fail <|
                            "Unexpected error in forced decoder failure test: " ++
                            Debug.toString result
        ]


-- USERS


type alias User =
    { id : Int
    , name : String
    }


userDecoder : Decoder User
userDecoder =
    Db.Decode.get2
        (Db.Decode.int "id")
        (Db.Decode.string "name")
        (\id name -> { id = id, name = name })


user1 : User
user1 =
    { id = 1, name = "one" }


user2 : User
user2 =
    { id = 2, name = "two" }


insertUsers : Db.Connection -> Array User -> Task Db.Error (Array Int)
insertUsers connection users =
    users
        |> Array.map
            (\{id, name} ->
                { statement = "insert into users (id, name) values (:id, :name)"
                , parameters =
                    [ Db.Encode.int "id" id
                    , Db.Encode.string "name" name
                    ]
                }
            )
        |> Db.transaction connection


initUsers : Db.Connection -> Array User -> Task Db.Error (Array Int)
initUsers connection users =
    reset connection
        |> Task.andThen (\_ -> insertUsers connection users)


getOneUser : Db.Connection -> Int -> Task Db.Error User
getOneUser connection id =
    Db.getOne connection
        { query = "select * from users where id = :id"
        , parameters = [ Db.Encode.int "id" id ]
        , decoder = userDecoder
        }


getMaybeOneUser : Db.Connection -> Int -> Task Db.Error (Maybe User)
getMaybeOneUser connection id =
    Db.getMaybeOne connection
        { query = "select * from users where id = :id"
        , parameters = [ Db.Encode.int "id" id ]
        , decoder = userDecoder
        }


getOneUserCustom : Db.Connection -> Int -> String -> Task Db.Error User
getOneUserCustom connection id query =
    Db.getOne connection
        { query = query
        , parameters = [ Db.Encode.int "id" id ]
        , decoder = userDecoder
        }


getMaybeOneUserCustom : Db.Connection -> Int -> String -> Task Db.Error (Maybe User)
getMaybeOneUserCustom connection id query =
    Db.getMaybeOne connection
        { query = query
        , parameters = [ Db.Encode.int "id" id ]
        , decoder = userDecoder
        }


getAllUsers : Db.Connection -> Task Db.Error (Array User)
getAllUsers connection =
    Db.getAll connection
        { query = "select * from users order by id"
        , parameters = []
        , decoder = userDecoder
        }


-- HELPERS


reset : Db.Connection -> Task Db.Error (Array Int)
reset connection =
    Db.transaction connection
        [ { parameters = []
          , statement =
            """
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER,
                name TEXT NOT NULL
            )
            """
          }
        , { parameters = []
          , statement =
            """
            CREATE TABLE IF NOT EXISTS allTypes (
                nullableInt INTEGER,
                float REAL NOT NULL,
                string TEXT NOT NULL,
                bool INTEGER,
                posix INTEGER
            )
            """
          }
        , { parameters = []
          , statement = "DELETE FROM users"
          }
        , { parameters = []
          , statement = "DELETE FROM allTypes"
          }
        ]


