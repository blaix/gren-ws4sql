module Db.Decode exposing
    ( Decoder
    , FieldDecoder

    -- Fields
    , bool
    , float
    , int
    , posix
    , string
    , maybe

    -- Mapping
    , map
    , map2
    , map3
    , map4
    , map5
    , map6
    , map7
    , map8

    -- ws4sql Helpers
    , ws4sqlQueryResponse
    , ws4sqlStatementResponse
    )

{-| Decode SQL results into Gren values.

These are typically used in the `Db.get*` functions via the `decoder` field,
where the string value matches the name of the field in the query.
For example:

    -- Assuming a table with id INTEGER, name TEXT
    Db.getOne connection
        { query = "select * from users where id = :id"
        , parameters = [ Db.Encode.int 1 ]
        , decoder = 
            Db.Decode.map2
                (Db.Decode.int "id")
                (Db.Decode.string "name")
                (\id name -> { id = id, name = name })
        }

@docs Decoder, FieldDecoder

## Fields

@docs string, int, float, bool, posix, maybe

## Mapping

Use these map functions to turn one or more field decoders into a full decoder.

@docs map, map2, map3, map4, map5, map6, map7, map8

## Util

You shouldn't need these unless you are bypassing this package's API
to interact with the ws4sql server directly.

@docs ws4sqlQueryResponse, ws4sqlStatementResponse
-}

import Db.Encode
import Json.Decode
import Json.Encode
import Time


{-| A decoder for a full record.

This is what's passed to the `decoder` field.
-}
type Decoder a
    = Decoder (Json.Decode.Decoder a)


{-| A decoder for an individual field.

This is what's passed to your [map](#mapping) functions.
-}
type FieldDecoder a
    = FieldDecoder
        { name : String
        , decoder : Json.Decode.Decoder a
        }


{-| Result of a failed attempt to decode.
-}
type Error
    = Error


-- FIELDS


{-| Decode a boolean field.
-}
bool : String -> FieldDecoder Bool
bool name =
    FieldDecoder
        { name = name
        , decoder =
            -- https://www.sqlite.org/datatype3.html#boolean_datatype
            Json.Decode.oneOf
                [ Json.Decode.int
                    |> Json.Decode.map (\i -> i /= 0)
                , Json.Decode.string
                    |> Json.Decode.andThen
                        (\s ->
                            when s is
                                "TRUE" -> Json.Decode.succeed True
                                "FALSE" -> Json.Decode.succeed False
                                _ -> Json.Decode.fail "Got unexpected string in boolean field"
                        )
                ]
        }


{-| Decode an integer field.
-}
int : String -> FieldDecoder Int
int name =
    FieldDecoder
        { name = name
        , decoder = Json.Decode.int
        }


{-| Decode a float field.
-}
float : String -> FieldDecoder Float
float name =
    FieldDecoder 
        { name = name
        , decoder = Json.Decode.float
        }


{-| Decode an integer field into a Time.Posix value.

The integer in the database should represent the number of milliseconds since 1970 January 1 at 00:00:00 UTC.
(See [Db.Encode.posix](Db.Encode#posix).
-}
posix : String -> FieldDecoder Time.Posix
posix name =
    FieldDecoder
        { name = name
        , decoder =
            Json.Decode.map
                Time.millisToPosix
                Json.Decode.int
        }


{-| Decode a string field.
-}
string : String -> FieldDecoder String
string name =
    FieldDecoder
        { name = name
        , decoder = Json.Decode.string
        }

{-| Decode a nullable field in the database.

The first parameter is the decoder function for the field type if the value is not null.
For example, to decode a nullable INTEGER field:

    Db.Decode.maybe Db.Decode.int "myField"
-}
maybe : (String -> FieldDecoder a) -> String -> FieldDecoder (Maybe a)
maybe toDecoder fieldName =
    let
        (FieldDecoder { name, decoder }) =
            toDecoder fieldName
    in
    FieldDecoder
        { name = name
        , decoder =
            Json.Decode.nullable decoder
        }


-- MAPPING


{-| Map a single field.
-}
map : FieldDecoder a -> (a -> b) -> Decoder b
map (FieldDecoder { name, decoder }) mapper =
    Decoder <|
        Json.Decode.map mapper
            (Json.Decode.field name decoder)

{-| Map 2 fields.
-}
map2 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    (a -> b -> c) -> 
    Decoder c
map2 (FieldDecoder a) (FieldDecoder b) mapper =
    Decoder <|
        Json.Decode.map2 mapper
            (Json.Decode.field a.name a.decoder)
            (Json.Decode.field b.name b.decoder)


{-| Map 3 fields.
-}
map3 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    (a -> b -> c -> d) -> 
    Decoder d
map3 (FieldDecoder a) (FieldDecoder b) (FieldDecoder c) mapper =
    Decoder <|
        Json.Decode.map3 mapper
            (Json.Decode.field a.name a.decoder)
            (Json.Decode.field b.name b.decoder)
            (Json.Decode.field c.name c.decoder)


{-| Map 4 fields.
-}
map4 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    FieldDecoder d -> 
    (a -> b -> c -> d -> e) -> 
    Decoder e
map4
    (FieldDecoder a)
    (FieldDecoder b)
    (FieldDecoder c)
    (FieldDecoder d)
    mapper =
        Decoder <|
            Json.Decode.map4 mapper
                (Json.Decode.field a.name a.decoder)
                (Json.Decode.field b.name b.decoder)
                (Json.Decode.field c.name c.decoder)
                (Json.Decode.field d.name d.decoder)


{-| Map 5 fields.
-}
map5 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    FieldDecoder d -> 
    FieldDecoder e -> 
    (a -> b -> c -> d -> e -> f) -> 
    Decoder f
map5
    (FieldDecoder a)
    (FieldDecoder b)
    (FieldDecoder c)
    (FieldDecoder d)
    (FieldDecoder e)
    mapper =
        Decoder <|
            Json.Decode.map5 mapper
                (Json.Decode.field a.name a.decoder)
                (Json.Decode.field b.name b.decoder)
                (Json.Decode.field c.name c.decoder)
                (Json.Decode.field d.name d.decoder)
                (Json.Decode.field e.name e.decoder)


{-| Map 6 fields.
-}
map6 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    FieldDecoder d -> 
    FieldDecoder e -> 
    FieldDecoder f -> 
    (a -> b -> c -> d -> e -> f -> g) -> 
    Decoder g
map6
    (FieldDecoder a)
    (FieldDecoder b)
    (FieldDecoder c)
    (FieldDecoder d)
    (FieldDecoder e)
    (FieldDecoder f)
    mapper =
        Decoder <|
            Json.Decode.map6 mapper
                (Json.Decode.field a.name a.decoder)
                (Json.Decode.field b.name b.decoder)
                (Json.Decode.field c.name c.decoder)
                (Json.Decode.field d.name d.decoder)
                (Json.Decode.field e.name e.decoder)
                (Json.Decode.field f.name f.decoder)


{-| Map 7 fields.
-}
map7 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    FieldDecoder d -> 
    FieldDecoder e -> 
    FieldDecoder f -> 
    FieldDecoder g -> 
    (a -> b -> c -> d -> e -> f -> g -> h) -> 
    Decoder h
map7
    (FieldDecoder a)
    (FieldDecoder b) 
    (FieldDecoder c)
    (FieldDecoder d)
    (FieldDecoder e)
    (FieldDecoder f)
    (FieldDecoder g)
    mapper =
        Decoder <|
            Json.Decode.map7 mapper
                (Json.Decode.field a.name a.decoder)
                (Json.Decode.field b.name b.decoder)
                (Json.Decode.field c.name c.decoder)
                (Json.Decode.field d.name d.decoder)
                (Json.Decode.field e.name e.decoder)
                (Json.Decode.field f.name f.decoder)
                (Json.Decode.field g.name g.decoder)


{-| Map 8 fields.
-}
map8 : 
    FieldDecoder a -> 
    FieldDecoder b -> 
    FieldDecoder c -> 
    FieldDecoder d -> 
    FieldDecoder e -> 
    FieldDecoder f -> 
    FieldDecoder g -> 
    FieldDecoder h -> 
    (a -> b -> c -> d -> e -> f -> g -> h -> i) -> 
    Decoder i
map8
    (FieldDecoder a)
    (FieldDecoder b)
    (FieldDecoder c)
    (FieldDecoder d)
    (FieldDecoder e)
    (FieldDecoder f)
    (FieldDecoder g)
    (FieldDecoder h)
    mapper =
        Decoder <|
            Json.Decode.map8 mapper
                (Json.Decode.field a.name a.decoder)
                (Json.Decode.field b.name b.decoder)
                (Json.Decode.field c.name c.decoder)
                (Json.Decode.field d.name d.decoder)
                (Json.Decode.field e.name e.decoder)
                (Json.Decode.field f.name f.decoder)
                (Json.Decode.field g.name g.decoder)
                (Json.Decode.field h.name h.decoder)


-- HELPERS


unwrap : Decoder a -> Json.Decode.Decoder a
unwrap (Decoder inner) =
    inner


{-| Get a json decoder for a raw ws4sql query response.
-}
ws4sqlQueryResponse : Decoder a -> Json.Decode.Decoder (Array a)
ws4sqlQueryResponse decoder =
    -- See https://germ.gitbook.io/ws4sqlite/documentation/responses
    -- We will get a response that looks like this:
    --     {
    --         "results": [
    --             {
    --                 "success": true,
    --                 "resultHeaders": [ "id", "name" ],
    --                 "resultSet": [
    --                     { "id": 1, "name": "Justin" }
    --                 ]
    --             }
    --          ]
    --     }
    Json.Decode.map Array.flatten <|
        Json.Decode.field "results" <|
            Json.Decode.array <|
                Json.Decode.field "resultSet" <|
                    Json.Decode.array <|
                        (unwrap decoder)


{-| Get a json decoder for a raw ws4sql statement response.
-}
ws4sqlStatementResponse : Json.Decode.Decoder (Array Int)
ws4sqlStatementResponse =
    -- See https://germ.gitbook.io/ws4sqlite/documentation/responses
    -- We will get a response that looks like this:
    --     {
    --         "results": [
    --             {
    --                 "success": true
    --                 "rowsUpdated": 1
    --             }
    --          ]
    --     }
    Json.Decode.field "results" <|
        Json.Decode.array <|
            Json.Decode.field "rowsUpdated" Json.Decode.int


